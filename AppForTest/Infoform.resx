<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="richTextBox1.Text" xml:space="preserve">
    <value>1.1)	 Способы описания и базовые структуры

Способы описания алгоритмов можно разделить на следующие пункты:
Словесная запись;
Псевдокод;
Схемы;
При словесной записи для описания каждого действия алгоритма используется набор фраз, в котором не должно быть лишних слов, повторений и неоднозначностей. Допускается использование математической символики. Каждое действие нумеруется, что даёт возможность в дальнейшем ссылаться на него. Действия выполняются по порядку, если явно не указано иное. Этот способ описания алгоритмов не используется широко из-за плохой наглядности.
Псевдокод основан на использовании системы словесных предписаний, которые описывают действия кода и его операции . У каждой операции есть свое название , которое должно легко интерпретироваться разработчиком любого программного языка . 
Ниже представлены примеры двух методов.
Словесная запись
Задача. Определить наибольший делитель натуральных чисел А,B.
Решение
1.Ввести A и B
2.Сравнить A и B
3.Если числа равны , то взять любое за ответ
4.Если числа не равны , то перейти к следующему.
5.Определить большее из чисел 
6. Заменить большее число-разностью большего и меньшего чисел. Перейти к п. 2
7.Вывести наибольший делитель
8.Конец алгоритма
   2) Псевдокод
	начало
		ввод(A,B)
			цикл пока (A != B)
				если (A == B) то C = A
				иначе
					если (A&gt;B) то A = A – B
					иначе B = B – A
					конец если (A &gt; B)
				конец если (A == B)
			конец цикла
		вывод
	конец

Самым распространенным является описание алгоритма в виде схемы из графических символов — блок-схемы. Данный метод используется в профессиональной.



Блок-схема алгоритма решения предыдущей задачи показана на рис. 1

Рисунок 1. Блок-схема алгоритма определения наибольшего делителя двух натуральных чисел





Базовые структуры алгоритмов :
1)линейная —все действия от ввода варьируемых исходных данных до определения искомого результата осуществляются последовательно, одно за другим.
2)разветвлённая —в зависимости от значения вычисленного условия последовательность действий может разветвляться на два или более направлений (ветвей);
3)циклическая —одна и та же последовательность действий выполняется многократно.

		Рисунок 2. Базовые структуры алгоритмов

Общие методы разработки алгоритмов
1.Метод частных целей (декомпозиции). Сложная задача сводится к последовательности более простых задач. При этом делаются следующие предположения:
*более простые задачи легче поддаются обработке, чем первоначальная задача;
*решение первоначальной задачи может быть получено из решения этих более простых задач. Метод частных целей бывает сложно перенести на конкретную задачу, так как осмысленный выбор более простых задач —больше искусство или интуиция, чем наука. Однако частные цели могут быть установлены после ответов на следующие вопросы:
1)Возможно ли решить только часть задачи? Можно ли, игнорируя некоторые условия, решить оставшуюся часть задачи?
2)Возможно ли решить задачу для частных случаев? Можно ли разработать алгоритм, дающий решение, удовлетворяющее всем условиям задачи, но входные данные которого ограничены?
3)Есть ли что-то, относящееся к задаче, но недостаточно хорошо понятое? Если глубже вникнуть в особенности задачи, можно ли узнать что-то, что поможет приблизить к решению ?
4)Встречалась ли раньше похожая задача, решение которой известно? Можно ли видоизменить ее решение для решения требуемой задачи? Возможно ли, что похожая решенная задача эквивалентна нерешенной?
2.Метод подъема. Алгоритм начинается с принятия начального предположения или вычисления начального решения задачи. Затем происходит быстрое движение «вверх» от начального решения по направлению к лучшим решениям. Когда алгоритм достигает точки, из которой больше невозможно двигаться наверх, он останавливается. При этом не всегда можно гарантировать, что окончательное решение будет оптимальным. Пример: определение экстремума функции двух переменных
3.Отрабатывание назад. Начинаем с цели или решения и движемся обратно по направлению к начальной постановке задачи. Если эти действия обратимы, в конечном алгоритме движемся, как обычно, от постановки задачи к решению. 

			Специальные методы разработки алгоритмов
1.Эвристика. Определяется как алгоритм со следующими свойствами:
*обычно определяет хорошие, но не обязательно оптимальные решения;
*его можно быстрее и проще реализовать, чем любой известный точный алгоритм, гарантирующий оптимальное решение
Часто очень хорошие алгоритмы должны рассматриваться как эвристические. Так, если быстрый алгоритм работает на всех тестовых задачах, но нельзя доказать, что он правильный, то его необходимо рассматривать как эвристику
2.Программирование с отходом назад. Это организованный исчерпывающий поиск по древовидной модели, который позволяет избежать исследования всех вариантов решения задачи. Метод удобен для решения задач, требующих проверки потенциально большого, но конечного числа решений.
3.Метод ветвей и границ. Похож на предыдущий метод тем, что исследует древовидную модель пространства решений и используется для решения многих дискретных комбинаторных задач. Однако он больше ориентирован на оптимизацию. В решаемой задаче определяется числовая функция стоимости для каждой из вершин в дереве поиска. Цель —определить конфигурацию, на которой функция стоимости достигает экстремального значения
4.Рекурсия. Это метод определения или выражения функции, языковой конструкции или решения задачи с помощью той же функции, языковой конструкции и т.д.
5.Имитационное (машинное) моделирование. Это компьютерный эксперимент над цифровой моделью сложной динамической системы. Используется
для решения задач, описывающих большие системы, например для военных расчетов, управления производством, сетей связи и т.п. Машинное моделирование позволяет получить информацию о системе, если проводить на ней прямой эксперимент непрактично. Имитационные эксперименты выполняются до того, как на соответствующую реальную систему затрачены время и деньги. Кроме того, их можно проводить в разных масштабах времени. Для детального изучения поведения системы время может быть замедлено, ускорено, остановлено, повернуто вспять или проиграно заново.



















2.2) Способы оценки эффективности и правила анализа алгоритмов
			Критерии оптимизации алгоритмов
При автоматизированном решении задач обработки данных выбрать или разработать алгоритм достаточно сложно, так как он должен удовлетворять двум противоречащим друг другу требованиям:
*быть простым для понимания, перевода в программный код и отладки;
*эффективно использовать вычислительные ресурсы и быстро выполняться
Первое требование существенно, если реализующая алгоритм программа будет выполняться только несколько раз. В этом случае минимизируют стоимость разработки алгоритма. Если программа будет выполняться многократно и потребует много вычислительных ресурсов, то стоимость её выполнения может превысить стоимость разработки алгоритма. Тогда более предпочтительной является разработка сложного, но быстрого алгоритма
Для оценки качества алгоритма вводится понятие «сложность» или обратное понятие «эффективность». Чем больше времени и памяти требуется для выполнения алгоритма, тем выше его сложность и соответственно ниже эффективность
Время выполнения большинства алгоритмов напрямую зависит от размера n входных данных, поэтому их эффективность (сложность) описывают в виде функции F(n). Так, для задач, связанных с сортировкой, поиском, определением наименьшего элемента, таким параметром будет размер массива или списка, то есть количество n его элементов
Типы эффективности (сложности) алгоритмов:

*временная эффективность T(n) — отражает скорость работы;
*пространственная эффективность V(n) — показывает ,сколько дополнительно необходимо оперативной памяти.
Обычно существенно улучшить можно именно скорость работы алгоритма , поэтому будем рассматривать только оценку временной эффективности. Пространственная эффективность оценивается аналогично
Способы оценки временной эффективности алгоритмов
Экспериментальный. Необходимо запрограммировать алгоритм и определить время выполнения программы, например, в секундах, миллисекундах и т.д. Однако экспериментальный способ имеет высокую стоимость, а на результаты измерений будут влиять:
*быстродействие конкретного компьютера;
*качество реализации алгоритма в виде программы;
*компилятор, используемый для генерации машинного кода;
*машинные инструкции, используемые при выполнении программы;
*точность измерения реального времени выполнения программы.
2. Теоретический. Сначала определяется , сколько раз выполняется каждая элементарная операция алгоритма. Затем рассчитывается сумма промежутков времени, необходимых для выполнения каждой операции:

Так, если I  я операция выполняется в течение времени ci и повторяется в алгоритме n раз, то её часть в суммарном времени работы алгоритма равна

Время выполнения алгоритмов может зависеть от упорядоченности входных данных или их значений. Так, время работы некоторых алгоритмов сортировки уменьшается, если входные данные частично упорядочены. Время работы алгоритма последовательного поиска наибольшее, если среди входных данных нет искомого элемента. Чтобы это учесть, различают эффективности:
1) в наихудшем случае Tmax(n) —для совокупности входных данных размером n, при которой время работы алгоритма наибольшее;
2) для среднего случая Tavg(n) —при обработке типовых или случайно заданных входных данных размером n;
3) в наилучшем случае Tmin(n) —для наилучшей совокупности входных данных размером n
На практике для оценки эффективности алгоритмов чаще всего используется наихудшее время, так как определение среднего времени выполнения является трудноразрешимой математической задачей
При малых размерах входных данных трудно заметить разницу во времени выполнения между эффективным и неэффективным алгоритмом. Для больших значений n вычисляют порядок (скорость) возрастания времени выполнения с точностью до постоянного множителя
Если время работы алгоритма выражается формулой
			
где a,bи c—некоторые константы, , то есть во внимание принимается только главный член формулы и игнорируется коэффициент перед ним.
Таким образом, если удвоить размер входных данных, то алгоритм будет работать приблизительно в 4раза медленнее. Константы a , b и c точно определить невозможно, так как они зависят от компилятора, компьютера и других факторов.
Приближенные значения основных функций, используемых при анализе алгоритмов , приведены в табл. 1.
Если для решения задачи с 1000 элементами алгоритму с логарифмическим порядком возрастания требуется 10 мс, то алгоритму с кубическим порядком возрастания — 278 часов. Основание логарифма обычно не указывается, так как можно перейти от одного основания к другому через постоянный множитель:

Приближенные значения основных функций, используемых при анализе алгоритмов

Таблица 1
Основные классы эффективности алгоритмов
1  константа. Характеризует алгоритмы, которые выполняются за фиксированное время, не зависящее от размера входных данных . 
log n—логарифмический. Типичен для алгоритмов, в которых на каждой итерации размер задачи сокращается на постоянную величину. Пример: алгоритм бинарного поиска.n—линейный. Характеризует алгоритмы, выполняющие сканирование списка из n элементов. Пример: алгоритм последовательного поиска . 
n log n  nlogn. Типичен для алгоритмов, разработанных по методу частных целей. Примеры: сортировка слиянием, быстрая сортировка . 
n^2—квадратичный. Характеризует алгоритмы, содержащие два вложенных цикла. Примеры: простые алгоритмы сортировки, алгоритмы обработки матриц размером 
n×n.n3—кубический. Типичен для алгоритмов, содержащих три вложенных цикла. Пример: сложные алгоритмы линейной алгебры.
2^n—экспоненциальный. Характеризует алгоритмы, выполняющие обработку всех подмножеств некоторого множества, состоящего из n элементов. Термин «экспоненциальный» часто используется в широком смысле и означает очень высокие порядки возрастания, более быстрые по сравнению с экспонентой.
n! —факториальный. Типичен для алгоритмов, выполняющих обработку всех перестановок некоторого множества, состоящего из nэлементов. Сравнение эффективности алгоритмов различных классов показано на рис.23
				Правила анализа алгоритмов
Для операций присваивания, чтения и записи, условных и логических операций время выполнения обычно имеет порядок возрастания (1). Исключением являются операторы присваивания, в которых операнды являются массивами или имеют вызовы функций
Время выполнения последовательности операций определяется с помощью правила сумм
Время выполнения ветвления состоит из времени вычисления логического выражения и наибольшего из времени, необходимого для выполнения операций при значении логического выражения истина (true) и при значении ложь (false)
Время выполнения цикла состоит из времени вычисления условия повторения цикла и произведения количества выполненных повторений на наибольшее время выполнения операций в теле цикла.
Время выполнения операции вызова функции определяется как время выполнения вызываемой функции.
При наличии в алгоритме операции безусловного перехода необходимо учитывать соответствующее ей изменение последовательности операций.

Рис. 3.Сравнение эффективности алгоритмов различных классов











2.3) Сортировка данных , поиск и алгоритмы разных типов сортировки
Сортировка — это упорядочивание последовательности элементов по возрастанию или убыванию их значений.
К алгоритмам  сортировки предъявляются  требования  высокого  быстро действия и экономного использования памяти. Эффективность алгоритмов сортировки зависит от количества сортируемых элементов, степени их упорядоченности и диапазона значений элементов.
Типы сортировки:
Внутренний —все данные полностью помещаются в оперативной памяти и возможен доступ к элементам последовательности в произвольном порядке. Является более быстродейственным.
Внешний —используется,  если  объем  данных очень большой,  что  не позволяет разместить их полностью в оперативной памяти. При этом данные хранятся на внешних запоминающих устройствах и возможен только последовательный  доступ  к  элементам.
Сортируемые объекты обычно являются структурами, содержащими одно или несколько полей. Задача сортировки состоит в их упорядочивании таким образом, чтобы значения ключевого поля составляли неубывающую (невозрастающую) последовательность. Если есть структуры с одинаковыми значениями ключей,  то  в  упорядоченной  последовательности  они  располагаются  рядом друг с другом в любом порядке.
Базовые алгоритмы внутренней сортировки:
1)Сортировка выбором (извлечением) - Массив делится на две части: отсортированную, или готовую последовательность A[0]...A[i–1],и неотсортированную, или исходную последовательностьA[i]...A[n–1]. На момент начала сортировки, при i=0, готовая последовательность считается пустой, а исходная последовательность содержит все  элементы  массива.  Происходит  поиск  одного элемента из исходной последовательности, который обладает наименьшим значением. Найденный элемент помещается в конец готовой последовательности. Этот процесс повторяется до тех пор, пока в исходной последовательности не останется один элемент с наибольшим значением, при этом i=n–1.
2)Сортировка подсчётом - На каждом шаге алгоритма, начиная с i=0 и до i=n–1, подсчитывается номер позиции k в результирующем массиве B, в которую  затем  записывается i-й  элемент  исходного  массива  A.  Номер  позиции складывается из числа элементов исходного массива, меньших i-го, а также не-которого числа равных ему. При подсчёте k из равных необходимо учитывать только те элементы исходного массива, которые стоят перед i-м.
3)Улучшенные алгоритмы внутренней сортировки:
4)Сортировка Шелла - Дональд  Шелл  предложил  улучшение  алгоритма  сортировки вставками, основанное на механизме, позволяющем увеличить расстояния, на которые перемещаются  элементы.  В  массиве  выделяются  группы  элементов,  отстоящие друг от друга на расстояние шага h, который первоначально имеет наибольшее значение. В каждой группе выполняется сортировка по алгоритму вставок. На очередном проходе  выделяются новые  группы  элементов,  отстоящие друг  от друга на меньшее расстояние, и вновь выполняется их сортировка. Выделение новых групп продолжается, пока шаг hне уменьшится до единицы. При этом выполняется  сортировка по  алгоритм у вставок  всего  массива. Так  как на предыдущих проходах массив был значительно упорядочен, на последнем число перестановок будет минимальным—в этом случае эффективность сортировки вставками достаточно высока.
5)Быстрая сортировка (сортировка разделением) - Является улучшением сортировки обменом и признана самым эффективным алгоритмом сортировки для больших объемов данных. Идея улучшения та же, что и в сортировке Шелла, —увеличение расстояния при обмене элементов местами. Быстрая сортировка разработана Чарльзом Хоаром и представляет со-бой рекурсивный алгоритм, основанный на принципе частных целей. Массив разделяется на две части относительно некоторого среднего элемента x.  В результате разделения в левой части массива оказываются все элементы, меньшие или равные x, а в правой части — большие или равные x. Затем выполняется рекурсивное разделение для каждой из этих частей и т.д. до тех пор, пока размер каждой части не станет равным 1.
6)Сортировка слиянием - Как и быстрая сортировка, данный алгоритм действует по схеме нисходящего рекурсивного разделения массива на части. Сначала массив разделяется на две равные части, затем выполняется деление каждой из частей ещё на две равные части и т.д., пока не будут получены части из одного элемента. После этого выполняется восходящее слияние смежных частей в упорядоченные части, содержащие по два элемента, по четыре элемента и т.д., пока не будет получена одна часть, соответствующая по размеру всему массиву.
7)Сортировка распределением (распределяющим подсчётом) - Предполагается, что каждый элемент исходного массива Aможет принимать только m фиксированных значений, например, от 0 доm–1. Сначала вводим вспомогательный массив int C[m] и обнуляем его элементы. Затем, начиная с i=0 и до i=n–1, к значению элемента вспомогательного массива с индексом, равным i-му элементу исходного массива, прибавляем единицу. Теперь в каждом j-м элементе вспомогательного массива записано количество элементов исходного массива, равных j. После этого преобразуем вспомогательный массив так, чтобы в C[j] было подсчитано количество элементов исходного массива, меньших или равных j. На последнем этапе, начиная с i=n–1 и до i=0, в позицию результирующего массива В  с  индексом  [C[A[i]]–1]  записываем i-й  эле-мент исходного массива и уменьшаем C[A[i]] на единицу.

Характеристики алгоритмов внутренней сортировки

Рисунок 2. Таблица характеристик алгоритмов
Особенности и алгоритмы внешней сортировки:
Внешняя сортировка  — это сортировка данных, хранящихся в виде фай-лов на внешнем устройстве с последовательным доступом к элементам (диске, ленте  и  т.п.).  В  этом  случае  необходимо  уменьшить  число  проходов  через файл.
Большой объем данных не позволяет переместить их полностью в оперативную память, отсортировать с использованием одного из алгоритмов внутренней сортировки и вернуть на внешнее устройство хранения. Иначе бы осуществлялось минимальное число проходов: однократное чтение и однократная запись данных. На практике приходится выполнять чтение из файла, обработку данных и запись в файл по блокам, размер которых зависит от операционной системы и доступного объема оперативной памяти. Это приводит к увеличению числа проходов через файл и уменьшению скорости сортировки.
Типы сортировки:
1)Сортировка файлов слиянием - сходный файл разбивается на два файла f1 и f2. Желательно, чтобы количество элементов в этих файлах было одинаковым. Сначала считаем, что файлы f1 и f2 состоят из участков длиной в один элемент.  Затем  производим  слияние  этих  участков  в  упорядоченные  участки длиной в два элемента, которые распределяем по файлам g1 и g2. После этого делаем файлы f1 и f2 пустыми и выполняем слияние участков из файлов g1 и g2 в упорядоченные участки длиной в четыре элемента, которые распределяем по файлам f1 и f2, и т.д. После  выполнения  i  таких  проходов  получаем  два  файла,  состоящие  из упорядоченных участков длиной 2i. При 2i≥n один из файлов станет пустым, а другой будет содержать упорядоченный участок длиной в n элементов, то есть будет отсортирован. Всего понадобится сделать порядка Θ(logn)проходов, так как 2i≥n при I ≥ log n.
2)При сортировке не требуется, чтобы отдельный участок полностью находился в оперативной памяти. Элементы участка считываются и записываются последовательно, один за другим, из-за чего используются два файла.
3)Эффективность алгоритма увеличивается на длинных участках, когда реже выполняются файловые операции. Можно модифицировать этот алгоритм так, чтобы сортировка начиналась с относительно длинных участков и стала более эффективной. Ускоренная  сортировка файлов слиянием. Данные исходного файла считываются в буфер оперативной памяти блоками по k элементов. Каждый блок сортируется с помощью улучшенного алгоритма внутренней сортировки и попеременно копируется в файлы f1 и f2. Слияние начинается с упорядоченных участков длиной в k элементов.

Поиск данных
	Поиск  наряду  с  сортировкой  является  наиболее  часто  встречающимся  в программировании обработки данных действием с данными. На вход алгоритма поиска подается последовательность из nэлементов a0,  a1, ... аn-1и ключевое значениеx. Задача поиска состоит в том, чтобы получить на выходе индекс i элемента, равного x, или выяснить, что такого элемента в данной последовательности нет.
Типы поиска:
1)внутренний —вся последовательность элементов постоянно находится в оперативной памяти
2)внешний —большая часть данных хранится на внешних запоминающих устройствах
Алгоритмы поиска:
Последовательный  (линейный)  поиск - Ключевое  значение xпоочередно сравнивается с элементами A[0], A[1], ... A[n–1]. Когда обнаружено совпадение, возвращается индекс i найденного элемента. Если после сравнения х со всеми элементами последовательности совпадений не найдено, то возвращается значение, которое не может быть индексом, например —– 1. При наличии в массиве нескольких элементов со значением xалгоритм находит только первый из них (с наименьшим индексом)
Поиск с барьером - В предыдущем алгоритме можно упростить логическое выражение цикла while, оставив только первую его часть. Однако тогда должно быть  гарантировано,  что  совпадение  с  ключом  рано  или  поздно  произойдет. Для этого в конец массива помещаем дополнительный элемент со значением x, называемый барьером, который не позволит выйти за пределы массива
Бинарный (двоичный) поиск - Существенно уменьшается количество проверок при поиске, когда имеется прямой доступ к элементам последовательности по индексу и элементы отсортированы, например, по возрастанию. Таким образом, бинарный поиск возможен только в упорядоченном массиве. Временная  эффективность  алгоритма  бинарного  поиска  имеет  порядок Θ(logn), так как на каждом шаге интервал поиска уменьшается в 2 раза. Если поиск в массиве выполняется разово, то проще воспользоваться последовательным поиском. В противном случае имеет смысл сначала упорядочить массив, а затем использовать бинарный поиск. Если предполагается выполнить mпоисков, то последовательный поиск обеспечит временную эффективность  порядка Θ(nm),  а  быстрая  сортировка  и  бинарный  поиск —Θ(nlogn+lognm).  Предварительная  сортировка  безусловно  оправдана  при большом количестве n элементов массива, а также когда данные можно упорядочить за линейное время.
Интерполяционный поиск - Аналог этого алгоритма — поиск фамилии на букву  «Б»  в  телефонном  справочнике,  когда  его  сразу  необходимо открыть намного ближе к началу, чем к средине. Так же и при поиске числа в упорядоченном массиве, интервал поиска можно делить на неравные части в соответствии с ключевым значением. Принимая априори гипотезу линейного  увеличения значений элементов массива вместе с их индексом, необходимо в алгоритме бинарного поиска заменить формулу m=(L+R)/2 на формулу . 
Индексный поиск - В дополнение  к  отсортированной  последовательности элементов  вводится  вспомогательная  таблица,  называемая индексом.  Каждая строка индекса состоит из ключа и указателя на элемент основной последовательности, содержащий этот ключ. Строки индекса должны быть отсортированы по значениям ключей. Основная  последовательность  разбивается  на  несколько  частей,  причем граничный элемент каждой части копируется в индекс. Поиск ключевого значения проводится в два этапа: сначала определяется его место в индексной таблице,  а  затем  выполняется  последовательный  или  бинарный  поиск  в  определённом интервале элементов основной последовательности. Можно добавлять любое число уровней индексов, соблюдая при этом оптимальное соотношение между размером основной последовательности и количеством  индексных  таблиц.  Индексный  поиск  применяется, когда  последовательность элементов является как массивом, так и списком.
</value>
  </data>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        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
</value>
  </data>
</root>